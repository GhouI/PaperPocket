"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  LlamaContext: true,
  toggleNativeLog: true,
  addNativeLogListener: true,
  setContextLimit: true,
  loadLlamaModelInfo: true,
  initLlama: true,
  releaseAllLlama: true,
  initContext: true,
  initMultimodal: true,
  isMultimodalEnabled: true,
  isMultimodalSupportVision: true,
  isMultimodalSupportAudio: true,
  releaseMultimodal: true,
  multimodalCompletion: true,
  initVocoder: true,
  isVocoderEnabled: true,
  getTTSType: true,
  getFormattedAudioCompletion: true,
  getAudioCompletionGuideTokens: true,
  decodeAudioTokens: true,
  releaseVocoder: true,
  tokenize: true,
  getDeviceInfo: true,
  Tools: true,
  parseAndExecuteTool: true,
  CactusLM: true,
  CactusVLM: true,
  CactusTTS: true,
  CactusAgent: true
};
Object.defineProperty(exports, "CactusAgent", {
  enumerable: true,
  get: function () {
    return _agent.CactusAgent;
  }
});
Object.defineProperty(exports, "CactusLM", {
  enumerable: true,
  get: function () {
    return _lm.CactusLM;
  }
});
Object.defineProperty(exports, "CactusTTS", {
  enumerable: true,
  get: function () {
    return _tts.CactusTTS;
  }
});
Object.defineProperty(exports, "CactusVLM", {
  enumerable: true,
  get: function () {
    return _vlm.CactusVLM;
  }
});
exports.LlamaContext = void 0;
Object.defineProperty(exports, "Tools", {
  enumerable: true,
  get: function () {
    return _tools.Tools;
  }
});
exports.addNativeLogListener = addNativeLogListener;
exports.initContext = exports.getTTSType = exports.getFormattedAudioCompletion = exports.getDeviceInfo = exports.getAudioCompletionGuideTokens = exports.decodeAudioTokens = void 0;
exports.initLlama = initLlama;
exports.isVocoderEnabled = exports.isMultimodalSupportVision = exports.isMultimodalSupportAudio = exports.isMultimodalEnabled = exports.initVocoder = exports.initMultimodal = void 0;
exports.loadLlamaModelInfo = loadLlamaModelInfo;
exports.multimodalCompletion = void 0;
Object.defineProperty(exports, "parseAndExecuteTool", {
  enumerable: true,
  get: function () {
    return _tools.parseAndExecuteTool;
  }
});
exports.releaseAllLlama = releaseAllLlama;
exports.releaseVocoder = exports.releaseMultimodal = void 0;
exports.setContextLimit = setContextLimit;
exports.toggleNativeLog = toggleNativeLog;
exports.tokenize = void 0;
var _reactNative = require("react-native");
var _NativeCactus = _interopRequireDefault(require("./NativeCactus"));
var _chat = require("./chat");
var _tools = require("./tools");
var _telemetry = require("./telemetry");
var _remote = require("./remote");
Object.keys(_remote).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _remote[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _remote[key];
    }
  });
});
var _lm = require("./lm");
var _vlm = require("./vlm");
var _tts = require("./tts");
var _agent = require("./agent");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const EVENT_ON_INIT_CONTEXT_PROGRESS = '@Cactus_onInitContextProgress';
const EVENT_ON_TOKEN = '@Cactus_onToken';
const EVENT_ON_NATIVE_LOG = '@Cactus_onNativeLog';
let EventEmitter;
if (_reactNative.Platform.OS === 'ios') {
  // @ts-ignore
  EventEmitter = new _reactNative.NativeEventEmitter(_NativeCactus.default);
}
if (_reactNative.Platform.OS === 'android') {
  EventEmitter = _reactNative.DeviceEventEmitter;
}
const logListeners = [];

// @ts-ignore
if (EventEmitter) {
  EventEmitter.addListener(EVENT_ON_NATIVE_LOG, evt => {
    logListeners.forEach(listener => listener(evt.level, evt.text));
  });
  _NativeCactus.default?.toggleNativeLog?.(false)?.catch?.(() => {});
}
const getJsonSchema = responseFormat => {
  if (responseFormat?.type === 'json_schema') {
    return responseFormat.json_schema?.schema;
  }
  if (responseFormat?.type === 'json_object') {
    return responseFormat.schema || {};
  }
  return null;
};
const telemetryParams = {
  n_gpu_layers: null,
  n_ctx: null,
  model: null
};
class LlamaContext {
  gpu = false;
  reasonNoGPU = '';
  constructor({
    contextId,
    gpu,
    reasonNoGPU,
    model
  }) {
    this.id = contextId;
    this.gpu = gpu;
    this.reasonNoGPU = reasonNoGPU;
    this.model = model;
  }
  async loadSession(filepath) {
    let path = filepath;
    if (path.startsWith('file://')) path = path.slice(7);
    return _NativeCactus.default.loadSession(this.id, path);
  }
  async saveSession(filepath, options) {
    return _NativeCactus.default.saveSession(this.id, filepath, options?.tokenSize || -1);
  }
  isLlamaChatSupported() {
    return !!this.model.chatTemplates.llamaChat;
  }
  isJinjaSupported() {
    const {
      minja
    } = this.model.chatTemplates;
    return !!minja?.toolUse || !!minja?.default;
  }
  async getFormattedChat(messages, template, params) {
    const chat = (0, _chat.formatChat)(messages);
    const useJinja = this.isJinjaSupported() && params?.jinja;
    let tmpl = this.isLlamaChatSupported() || useJinja ? undefined : 'chatml';
    if (template) tmpl = template; // Force replace if provided
    const jsonSchema = getJsonSchema(params?.response_format);
    return _NativeCactus.default.getFormattedChat(this.id, JSON.stringify(chat), tmpl, {
      jinja: useJinja,
      json_schema: jsonSchema ? JSON.stringify(jsonSchema) : undefined,
      tools: params?.tools ? JSON.stringify(params.tools) : undefined,
      parallel_tool_calls: params?.parallel_tool_calls ? JSON.stringify(params.parallel_tool_calls) : undefined,
      tool_choice: params?.tool_choice
    });
  }
  async completionWithTools(params, callback, recursionCount = 0, recursionLimit = 3) {
    if (!params.messages) {
      return this.completion(params, callback);
    }
    if (!params.tools) {
      return this.completion(params, callback);
    }
    if (recursionCount >= recursionLimit) {
      return this.completion({
        ...params,
        jinja: true,
        tools: params.tools.getSchemas()
      }, callback);
    }
    const messages = [...params.messages];
    const result = await this.completion({
      ...params,
      messages: messages,
      jinja: true,
      tools: params.tools.getSchemas()
    }, callback);
    const {
      toolCalled,
      toolName,
      toolInput,
      toolOutput
    } = await (0, _tools.parseAndExecuteTool)(result, params.tools);
    if (toolCalled && toolName && toolInput) {
      const assistantMessage = {
        role: 'assistant',
        content: result.content,
        tool_calls: result.tool_calls
      };
      messages.push(assistantMessage);
      const toolCallId = result.tool_calls?.[0]?.id;
      const toolMessage = {
        role: 'tool',
        content: JSON.stringify(toolOutput),
        tool_call_id: toolCallId
      };
      messages.push(toolMessage);
      return await this.completionWithTools({
        ...params,
        messages: messages
      }, callback, recursionCount + 1, recursionLimit);
    }
    return result;
  }
  async completion(params, callback) {
    const nativeParams = {
      ...params,
      prompt: params.prompt || '',
      emit_partial_completion: !!callback
    };
    if (params.messages) {
      const formattedResult = await this.getFormattedChat(params.messages, params.chat_template || params.chatTemplate, {
        jinja: params.jinja,
        tools: params.tools,
        parallel_tool_calls: params.parallel_tool_calls,
        tool_choice: params.tool_choice
      });
      if (typeof formattedResult === 'string') {
        nativeParams.prompt = formattedResult || '';
      } else {
        nativeParams.prompt = formattedResult.prompt || '';
        if (typeof formattedResult.chat_format === 'number') nativeParams.chat_format = formattedResult.chat_format;
        if (formattedResult.grammar) nativeParams.grammar = formattedResult.grammar;
        if (typeof formattedResult.grammar_lazy === 'boolean') nativeParams.grammar_lazy = formattedResult.grammar_lazy;
        if (formattedResult.grammar_triggers) nativeParams.grammar_triggers = formattedResult.grammar_triggers;
        if (formattedResult.preserved_tokens) nativeParams.preserved_tokens = formattedResult.preserved_tokens;
        if (formattedResult.additional_stops) {
          if (!nativeParams.stop) nativeParams.stop = [];
          nativeParams.stop.push(...formattedResult.additional_stops);
        }
      }
    } else {
      nativeParams.prompt = params.prompt || '';
    }
    if (nativeParams.response_format && !nativeParams.grammar) {
      const jsonSchema = getJsonSchema(params.response_format);
      if (jsonSchema) nativeParams.json_schema = JSON.stringify(jsonSchema);
    }
    const startTime = Date.now();
    let firstTokenTime = null;
    const deviceInfo = await getDeviceInfo(this.id);
    const wrappedCallback = callback ? data => {
      if (firstTokenTime === null) firstTokenTime = Date.now();
      callback(data);
    } : undefined;
    let tokenListener = wrappedCallback && EventEmitter.addListener(EVENT_ON_TOKEN, evt => {
      const {
        contextId,
        tokenResult
      } = evt;
      if (contextId !== this.id) return;
      wrappedCallback(tokenResult);
    });
    if (!nativeParams.prompt) throw new Error('Prompt is required');
    const promise = _NativeCactus.default.completion(this.id, nativeParams);
    return promise.then(completionResult => {
      _telemetry.Telemetry.track({
        event: 'completion',
        tok_per_sec: completionResult.timings?.predicted_per_second,
        toks_generated: completionResult.timings?.predicted_n,
        ttft: firstTokenTime ? firstTokenTime - startTime : null
      }, telemetryParams, deviceInfo);
      tokenListener?.remove();
      tokenListener = null;
      return completionResult;
    }).catch(err => {
      tokenListener?.remove();
      tokenListener = null;
      throw err;
    });
  }
  stopCompletion() {
    return _NativeCactus.default.stopCompletion(this.id);
  }
  tokenize(text) {
    return _NativeCactus.default.tokenize(this.id, text);
  }
  detokenize(tokens) {
    return _NativeCactus.default.detokenize(this.id, tokens);
  }
  async embedding(text, params) {
    const startTime = Date.now();
    const embeddingResult = await _NativeCactus.default.embedding(this.id, text, params || {});
    const totalTime = Date.now() - startTime;
    const deviceInfo = await getDeviceInfo(this.id);
    _telemetry.Telemetry.track({
      event: 'embedding',
      mode: 'local',
      embedding_time: totalTime
    }, telemetryParams, deviceInfo);
    return embeddingResult;
  }
  async bench(pp, tg, pl, nr) {
    const result = await _NativeCactus.default.bench(this.id, pp, tg, pl, nr);
    const [modelDesc, modelSize, modelNParams, ppAvg, ppStd, tgAvg, tgStd] = JSON.parse(result);
    return {
      modelDesc,
      modelSize,
      modelNParams,
      ppAvg,
      ppStd,
      tgAvg,
      tgStd
    };
  }
  async applyLoraAdapters(loraList) {
    let loraAdapters = [];
    if (loraList) loraAdapters = loraList.map(l => ({
      path: l.path.replace(/file:\/\//, ''),
      scaled: l.scaled
    }));
    return _NativeCactus.default.applyLoraAdapters(this.id, loraAdapters);
  }
  async removeLoraAdapters() {
    return _NativeCactus.default.removeLoraAdapters(this.id);
  }
  async getLoadedLoraAdapters() {
    return _NativeCactus.default.getLoadedLoraAdapters(this.id);
  }
  async release() {
    return _NativeCactus.default.releaseContext(this.id);
  }
  async rewind() {
    return _NativeCactus.default.rewind(this.id);
  }
}
exports.LlamaContext = LlamaContext;
async function toggleNativeLog(enabled) {
  return _NativeCactus.default.toggleNativeLog(enabled);
}
function addNativeLogListener(listener) {
  logListeners.push(listener);
  return {
    remove: () => {
      logListeners.splice(logListeners.indexOf(listener), 1);
    }
  };
}
async function setContextLimit(limit) {
  return _NativeCactus.default.setContextLimit(limit);
}
let contextIdCounter = 0;
const contextIdRandom = () => process.env.NODE_ENV === 'test' ? 0 : Math.floor(Math.random() * 100000);
const modelInfoSkip = [
// Large fields
'tokenizer.ggml.tokens', 'tokenizer.ggml.token_type', 'tokenizer.ggml.merges', 'tokenizer.ggml.scores'];
async function loadLlamaModelInfo(model) {
  let path = model;
  if (path.startsWith('file://')) path = path.slice(7);
  return _NativeCactus.default.modelInfo(path, modelInfoSkip);
}
const poolTypeMap = {
  none: 0,
  mean: 1,
  cls: 2,
  last: 3,
  rank: 4
};
async function initLlama({
  model,
  is_model_asset: isModelAsset,
  pooling_type: poolingType,
  lora,
  lora_list: loraList,
  ...rest
}, onProgress) {
  let path = model;
  if (path.startsWith('file://')) path = path.slice(7);
  let loraPath = lora;
  if (loraPath?.startsWith('file://')) loraPath = loraPath.slice(7);
  let loraAdapters = [];
  if (loraList) loraAdapters = loraList.map(l => ({
    path: l.path.replace(/file:\/\//, ''),
    scaled: l.scaled
  }));
  telemetryParams.n_gpu_layers = rest.n_gpu_layers || null;
  telemetryParams.n_ctx = rest.n_ctx || null;
  telemetryParams.model = model;
  const contextId = contextIdCounter + contextIdRandom();
  contextIdCounter += 1;
  let removeProgressListener = null;
  if (onProgress) {
    removeProgressListener = EventEmitter.addListener(EVENT_ON_INIT_CONTEXT_PROGRESS, evt => {
      if (evt.contextId !== contextId) return;
      onProgress(evt.progress);
    });
  }
  const poolType = poolTypeMap[poolingType];
  const {
    gpu,
    reasonNoGPU,
    model: modelDetails,
    androidLib
  } = await _NativeCactus.default.initContext(contextId, {
    model: path,
    is_model_asset: !!isModelAsset,
    use_progress_callback: !!onProgress,
    pooling_type: poolType,
    lora: loraPath,
    lora_list: loraAdapters,
    ...rest
  }).catch(err => {
    removeProgressListener?.remove();
    throw err;
  });
  removeProgressListener?.remove();
  return new LlamaContext({
    contextId,
    gpu,
    reasonNoGPU,
    model: modelDetails,
    androidLib
  });
}
async function releaseAllLlama() {
  return _NativeCactus.default.releaseAllContexts();
}
const initContext = async params => {
  return await _NativeCactus.default.initContext(contextIdCounter++, params);
};
exports.initContext = initContext;
const initMultimodal = async (contextId, mmprojPath, useGpu = false) => {
  return await _NativeCactus.default.initMultimodal(contextId, mmprojPath, useGpu);
};
exports.initMultimodal = initMultimodal;
const isMultimodalEnabled = async contextId => {
  return await _NativeCactus.default.isMultimodalEnabled(contextId);
};
exports.isMultimodalEnabled = isMultimodalEnabled;
const isMultimodalSupportVision = async contextId => {
  return await _NativeCactus.default.isMultimodalSupportVision(contextId);
};
exports.isMultimodalSupportVision = isMultimodalSupportVision;
const isMultimodalSupportAudio = async contextId => {
  return await _NativeCactus.default.isMultimodalSupportAudio(contextId);
};
exports.isMultimodalSupportAudio = isMultimodalSupportAudio;
const releaseMultimodal = async contextId => {
  return await _NativeCactus.default.releaseMultimodal(contextId);
};
exports.releaseMultimodal = releaseMultimodal;
const multimodalCompletion = async (contextId, prompt, mediaPaths, params) => {
  const result = await _NativeCactus.default.multimodalCompletion(contextId, prompt, mediaPaths, params);
  const deviceInfo = await getDeviceInfo(contextId);
  _telemetry.Telemetry.track({
    event: 'completion',
    tok_per_sec: result.timings?.predicted_per_second,
    toks_generated: result.timings?.predicted_n,
    num_images: mediaPaths?.length
  }, telemetryParams, deviceInfo);
  return result;
};
exports.multimodalCompletion = multimodalCompletion;
const initVocoder = async (contextId, vocoderModelPath) => {
  return await _NativeCactus.default.initVocoder(contextId, vocoderModelPath);
};
exports.initVocoder = initVocoder;
const isVocoderEnabled = async contextId => {
  return await _NativeCactus.default.isVocoderEnabled(contextId);
};
exports.isVocoderEnabled = isVocoderEnabled;
const getTTSType = async contextId => {
  return await _NativeCactus.default.getTTSType(contextId);
};
exports.getTTSType = getTTSType;
const getFormattedAudioCompletion = async (contextId, speakerJsonStr, textToSpeak) => {
  return await _NativeCactus.default.getFormattedAudioCompletion(contextId, speakerJsonStr, textToSpeak);
};
exports.getFormattedAudioCompletion = getFormattedAudioCompletion;
const getAudioCompletionGuideTokens = async (contextId, textToSpeak) => {
  return await _NativeCactus.default.getAudioCompletionGuideTokens(contextId, textToSpeak);
};
exports.getAudioCompletionGuideTokens = getAudioCompletionGuideTokens;
const decodeAudioTokens = async (contextId, tokens) => {
  return await _NativeCactus.default.decodeAudioTokens(contextId, tokens);
};
exports.decodeAudioTokens = decodeAudioTokens;
const releaseVocoder = async contextId => {
  return await _NativeCactus.default.releaseVocoder(contextId);
};
exports.releaseVocoder = releaseVocoder;
const tokenize = async (contextId, text, mediaPaths) => {
  if (mediaPaths && mediaPaths.length > 0) {
    return await _NativeCactus.default.tokenize(contextId, text, mediaPaths);
  } else {
    return await _NativeCactus.default.tokenize(contextId, text);
  }
};
exports.tokenize = tokenize;
const getDeviceInfo = async contextId => {
  return await _NativeCactus.default.getDeviceInfo(contextId);
};
exports.getDeviceInfo = getDeviceInfo;
//# sourceMappingURL=index.js.map