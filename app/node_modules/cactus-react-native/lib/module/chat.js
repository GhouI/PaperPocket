"use strict";

export function formatChat(messages) {
  const chat = [];
  messages.forEach(currMsg => {
    const role = currMsg.role || '';
    let content = '';
    if ('content' in currMsg) {
      if (typeof currMsg.content === 'string') {
        ;
        ({
          content
        } = currMsg);
      } else if (Array.isArray(currMsg.content)) {
        currMsg.content.forEach(part => {
          if ('text' in part) {
            content += `${content ? '\n' : ''}${part.text}`;
          }
        });
      } else {
        throw new TypeError("Invalid 'content' type (ref: https://github.com/ggerganov/llama.cpp/issues/8367)");
      }
    } else {
      throw new Error("Missing 'content' (ref: https://github.com/ggerganov/llama.cpp/issues/8367)");
    }
    chat.push({
      role,
      content
    });
  });
  return chat;
}
export class ConversationHistoryManager {
  history = [];
  processNewMessages(fullMessageHistory) {
    let divergent = fullMessageHistory.length < this.history.length;
    if (!divergent) {
      for (let i = 0; i < this.history.length; i++) {
        if (JSON.stringify(this.history[i]) !== JSON.stringify(fullMessageHistory[i])) {
          divergent = true;
          break;
        }
      }
    }
    if (divergent) {
      return {
        newMessages: fullMessageHistory,
        requiresReset: true
      };
    }
    const newMessages = fullMessageHistory.slice(this.history.length);
    return {
      newMessages,
      requiresReset: false
    };
  }
  update(newMessages, assistantResponse) {
    this.history.push(...newMessages, assistantResponse);
  }
  reset() {
    this.history = [];
  }
  getMessages() {
    return this.history;
  }
}
//# sourceMappingURL=chat.js.map