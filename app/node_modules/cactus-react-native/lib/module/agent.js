"use strict";

import { CactusLM } from './lm';
import { Tools } from './tools';
export class CactusAgent extends CactusLM {
  static async init(params, onProgress, cactusToken, retryOptions) {
    const result = await CactusLM.init(params, onProgress, cactusToken, retryOptions);
    if (result.error || !result.lm) {
      return {
        agent: null,
        error: result.error,
        lm: null
      };
    }
    const agent = Object.setPrototypeOf(result.lm, CactusAgent.prototype);
    agent.tools = new Tools();
    return {
      agent,
      error: null,
      lm: agent
    };
  }
  addTool(func, description, parameters) {
    return this.tools.add(func, description, parameters);
  }
  getTools() {
    return this.tools;
  }
  async completionWithTools(messages, params = {}, callback, recursionCount = 0, recursionLimit = 3) {
    const tools = params.tools || this.tools;
    if (!messages?.length) {
      return this.completion([], params, callback);
    }
    if (!tools || tools.getSchemas().length === 0) {
      return this.completion(messages, params, callback);
    }
    if (recursionCount >= recursionLimit) {
      return this.completion(messages, {
        ...params,
        jinja: true,
        tools: tools.getSchemas()
      }, callback);
    }
    const {
      newMessages,
      requiresReset
    } = this.conversationHistoryManager.processNewMessages(messages);
    if (requiresReset) {
      this.context?.rewind();
      this.conversationHistoryManager.reset();
    }
    const result = await this.context.completionWithTools({
      ...params,
      messages: newMessages.length > 0 ? newMessages : messages,
      tools: tools
    }, callback, recursionCount, recursionLimit);
    this.conversationHistoryManager.update(newMessages.length > 0 ? newMessages : messages, {
      role: 'assistant',
      content: result.content,
      tool_calls: result.tool_calls
    });
    return result;
  }
  isJinjaSupported() {
    return this.context.isJinjaSupported();
  }
}
//# sourceMappingURL=agent.js.map